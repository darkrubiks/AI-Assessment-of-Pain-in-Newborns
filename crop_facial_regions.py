"""Utility to crop facial regions from images using precomputed landmarks.

This script iterates over an input directory, looks for image files and, for
each image, loads a pickle file containing 2D facial landmarks with the same
filename (but ``.pkl`` extension). The landmarks are converted into semantic
facial regions using :func:`create_face_regions_masks` and each region is
cropped from the image and written to disk.

Example
-------

.. code-block:: bash

    python crop_facial_regions.py --images ./Datasets/DatasetFaces/Images --landmarks ./Datasets/DatasetFaces/Landmarks --output ./cropped_regions

The command above will create one folder per region inside ``./cropped_regions``
containing the cropped images. Passing ``--square`` expands each crop to the
smallest possible square that still contains the detected facial area.
"""

from __future__ import annotations

import argparse
import logging
import pickle
from pathlib import Path
from typing import Dict, Iterable, Optional, Tuple

import cv2
import numpy as np

from XAI.metrics import create_face_regions_masks


LOGGER = logging.getLogger(__name__)


IMAGE_EXTENSIONS = {".png", ".jpg", ".jpeg", ".bmp", ".tif", ".tiff"}


REGION_RENAMES = {
    "left_eyebrown": "left_eyebrow",
    "right_eyebrown": "right_eyebrow",
}


REQUIRED_REGION_NAMES = {
    "left_eye",
    "right_eye",
    "left_eyebrow",
    "right_eyebrow",
}


def parse_arguments() -> argparse.Namespace:
    """Parse command line arguments."""

    parser = argparse.ArgumentParser(
        description="Crop semantic face regions using 2D landmarks",
    )
    parser.add_argument(
        "--images",
        type=Path,
        required=False,
        help="Directory containing the facial images.",
    )
    parser.add_argument(
        "--landmarks",
        type=Path,
        required=False,
        help=(
            "Directory containing landmark pickle files. If omitted, the script "
            "expects the pickle files to live alongside their corresponding "
            "images."
        ),
    )
    parser.add_argument(
        "--output",
        type=Path,
        required=True,
        help="Destination directory for the cropped regions.",
    )
    parser.add_argument(
        "--include-outside",
        action="store_true",
        help="Also generate crops for the 'outside' region.",
    )
    parser.add_argument(
        "--overwrite",
        action="store_true",
        help="Overwrite existing output files if present.",
    )
    parser.add_argument(
        "--square",
        action="store_true",
        help=(
            "Expand each crop to the smallest possible square that still contains the "
            "facial region. The square is clipped to the image boundaries."
        ),
    )
    parser.add_argument(
        "--log-level",
        default="INFO",
        choices=["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
        help="Logging verbosity level.",
    )

    return parser.parse_args()


def iter_image_files(image_dir: Path) -> Iterable[Path]:
    """Yield image paths from ``image_dir`` with supported extensions."""

    for path in sorted(image_dir.iterdir()):
        if path.is_file() and path.suffix.lower() in IMAGE_EXTENSIONS:
            yield path


def load_landmarks(landmarks_path: Path) -> Optional[np.ndarray]:
    """Load landmarks from a pickle file.

    The pickle files generated by :mod:`face_detection.py` store a numpy array
    with 106 keypoints already scaled to a ``512x512`` canvas. This function is
    defensive and converts lists into :class:`numpy.ndarray` when necessary.
    """

    try:
        with landmarks_path.open("rb") as handle:
            keypoints = pickle.load(handle)
    except FileNotFoundError:
        LOGGER.warning("Landmarks not found: %s", landmarks_path)
        return None
    except pickle.UnpicklingError as exc:
        LOGGER.error("Could not read landmarks %s: %s", landmarks_path, exc)
        return None

    keypoints_array = np.asarray(keypoints, dtype=np.float32)

    if keypoints_array.ndim != 2 or keypoints_array.shape[1] != 2:
        LOGGER.error(
            "Unexpected landmarks shape for %s: %s",
            landmarks_path,
            keypoints_array.shape,
        )
        return None

    return keypoints_array


def mask_to_bbox(mask: np.ndarray) -> Optional[Tuple[int, int, int, int]]:
    """Return the bounding box of a binary mask as ``(x_min, y_min, x_max, y_max)``."""

    ys, xs = np.nonzero(mask)
    if len(xs) == 0 or len(ys) == 0:
        return None

    x_min = int(xs.min())
    x_max = int(xs.max() + 1)
    y_min = int(ys.min())
    y_max = int(ys.max() + 1)

    return x_min, y_min, x_max, y_max


def square_bbox(
    bbox: Tuple[int, int, int, int],
    image_shape: Tuple[int, int],
) -> Tuple[int, int, int, int]:
    """Expand ``bbox`` to a square while keeping it inside ``image_shape`` boundaries."""

    x_min, y_min, x_max, y_max = bbox
    height = y_max - y_min
    width = x_max - x_min
    side = int(np.ceil(max(width, height)))

    # Center of the original bounding box
    center_x = (x_min + x_max) / 2.0
    center_y = (y_min + y_max) / 2.0

    half_side = side / 2.0
    new_x_min = int(round(center_x - half_side))
    new_y_min = int(round(center_y - half_side))
    new_x_max = new_x_min + side
    new_y_max = new_y_min + side

    image_height, image_width = image_shape

    # Clamp the square to fit within the image boundaries while preserving size as much as possible
    if new_x_min < 0:
        new_x_max -= new_x_min
        new_x_min = 0
    if new_y_min < 0:
        new_y_max -= new_y_min
        new_y_min = 0
    if new_x_max > image_width:
        shift = new_x_max - image_width
        new_x_min = max(0, new_x_min - shift)
        new_x_max = image_width
    if new_y_max > image_height:
        shift = new_y_max - image_height
        new_y_min = max(0, new_y_min - shift)
        new_y_max = image_height

    return new_x_min, new_y_min, new_x_max, new_y_max


def save_region_crop(
    image: np.ndarray,
    mask: np.ndarray,
    output_path: Path,
    overwrite: bool = False,
    make_square: bool = False,
) -> bool:
    """Apply ``mask`` on ``image`` and write the resulting crop to ``output_path``."""

    mask_binary = mask > 0
    bbox = mask_to_bbox(mask_binary)
    if bbox is None:
        LOGGER.debug("Mask %s produced an empty bounding box", output_path.stem)
        return False

    x_min, y_min, x_max, y_max = bbox
    if make_square:
        x_min, y_min, x_max, y_max = square_bbox(
            (x_min, y_min, x_max, y_max), image.shape[:2]
        )

    crop = image[y_min:y_max, x_min:x_max]
    if crop.size == 0:
        LOGGER.debug("Empty crop for %s", output_path.stem)
        return False

    if output_path.exists() and not overwrite:
        LOGGER.debug("Skipping existing file %s", output_path)
        return True

    output_path.parent.mkdir(parents=True, exist_ok=True)
    crop = cv2.resize(crop, (128,128))
    success = cv2.imwrite(str(output_path), crop)
    if not success:
        LOGGER.error("Failed to write %s", output_path)
    return success


def build_region_masks(
    keypoints: np.ndarray,
    target_shape: tuple[int, int],
    include_outside: bool = False,
) -> Dict[str, np.ndarray]:
    """Return resized region masks for the current image shape."""

    raw_masks = create_face_regions_masks(keypoints)

    masks: Dict[str, np.ndarray] = {}
    image_height, image_width = target_shape

    for region_name, mask in raw_masks.items():
        if not include_outside and region_name == "outside":
            continue

        resized_mask = cv2.resize(
            mask,
            (image_width, image_height),
            interpolation=cv2.INTER_NEAREST,
        )

        kernel = np.ones((9, 9), np.uint8)  # k controls how many pixels to grow
        expanded_mask = cv2.dilate(resized_mask, kernel, iterations=5)

        output_name = REGION_RENAMES.get(region_name, region_name)
        masks[output_name] = expanded_mask

    missing_regions = REQUIRED_REGION_NAMES - masks.keys()
    if missing_regions:
        LOGGER.warning("Missing expected regions in masks: %s", sorted(missing_regions))

    return masks


def process_image(
    image_path: Path,
    landmarks_dir: Path,
    output_dir: Path,
    include_outside: bool,
    overwrite: bool,
    make_square: bool,
) -> None:
    """Load image and generate crops for each face region."""

    image = cv2.imread(str(image_path))
    if image is None:
        LOGGER.error("Could not read image %s", image_path)
        return

    landmarks_path = landmarks_dir / (image_path.stem + ".pkl")
    keypoints = load_landmarks(landmarks_path)
    if keypoints is None:
        return

    region_masks = build_region_masks(
        keypoints,
        target_shape=image.shape[:2],
        include_outside=include_outside,
    )

    for region_name, mask in region_masks.items():
        output_path = output_dir / region_name / f"{image_path.stem}_{region_name}{image_path.suffix}"
        saved = save_region_crop(
            image=image,
            mask=mask,
            output_path=output_path,
            overwrite=overwrite,
            make_square=make_square,
        )
        if saved:
            LOGGER.debug("Saved %s", output_path)


def main() -> None:
    """Script entry-point."""

    args = parse_arguments()
    logging.basicConfig(level=getattr(logging, args.log_level))

    image_dir = Path("Datasets\\DatasetFaces\\Images")
    landmarks_dir = Path("Datasets\\DatasetFaces\\Landmarks")
    output_dir = args.output

    if not image_dir.exists() or not image_dir.is_dir():
        raise FileNotFoundError(f"Image directory not found: {image_dir}")

    if not landmarks_dir.exists() or not landmarks_dir.is_dir():
        raise FileNotFoundError(f"Landmarks directory not found: {landmarks_dir}")

    LOGGER.info("Reading images from %s", image_dir)
    LOGGER.info("Reading landmarks from %s", landmarks_dir)
    LOGGER.info("Saving crops into %s", output_dir)

    for image_path in iter_image_files(image_dir):
        LOGGER.info("Processing %s", image_path.name)
        process_image(
            image_path=image_path,
            landmarks_dir=landmarks_dir,
            output_dir=output_dir,
            include_outside=args.include_outside,
            overwrite=args.overwrite,
            make_square=args.square,
        )


if __name__ == "__main__":
    main()

